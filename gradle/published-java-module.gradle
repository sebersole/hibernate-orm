/*
 * Hibernate, Relational Persistence for Idiomatic Java
 *
 * License: GNU Lesser General Public License (LGPL), version 2.1 or later
 * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html
 */

apply from: rootProject.file( 'gradle/releasable.gradle' )
apply from: rootProject.file( 'gradle/java-module.gradle' )
apply from: rootProject.file( 'gradle/publishing-pom.gradle' )

apply plugin: 'signing'

tasks.getByPath( ':release:publishReleaseArtifacts' ).dependsOn tasks.release

configurations {
	javadocSources {
		description 'Used to aggregate javadocs for the whole project'
	}
}

dependencies {
	javadocSources sourceSets.main.allJava
}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Publishing

java {
	withJavadocJar()
	withSourcesJar()
}

publishing {
	publications {
		// main publication
		publishedArtifacts {
			from components.java
		}

		// relocation for the published artifacts based on the old groupId
		relocationPom( MavenPublication ) {
			pom {
				name = project.name + ' - relocation'
				groupId = 'org.hibernate'
				artifactId = project.name
				version = project.version

				description = project.description
				url = 'https://hibernate.org/orm'

				organization {
					name = 'Hibernate.org'
					url = 'https://hibernate.org'
				}

				licenses {
					license {
						name = 'GNU Library General Public License v2.1 or later'
						url = 'https://www.opensource.org/licenses/LGPL-2.1'
						comments = 'See discussion at https://hibernate.org/community/license/ for more details.'
						distribution = 'repo'
					}
				}

				scm {
					url = 'https://github.com/hibernate/hibernate-orm'
					connection = 'scm:git:https://github.com/hibernate/hibernate-orm.git'
					developerConnection = 'scm:git:git@github.com:hibernate/hibernate-orm.git'
				}

				developers {
					developer {
						id = 'hibernate-team'
						name = 'The Hibernate Development Team'
						organization = 'Hibernate.org'
						organizationUrl = 'https://hibernate.org'
					}
				}

				issueManagement {
					system = 'jira'
					url = 'https://hibernate.atlassian.net/browse/HHH'
				}

				distributionManagement {
					relocation {
						groupId = 'org.hibernate.orm'
						artifactId = project.name
						version = project.version
					}
				}
			}
		}
	}
}


var signingKey = resolveSigningKey()
var signingPassword = findSigningProperty( "signingPassword" )

signing {
	useInMemoryPgpKeys( signingKey, signingPassword )

	sign publishing.publications.publishedArtifacts
}

String resolveSigningKey() {
	var key = findSigningProperty( "signingKey" )
	if ( key != null ) {
		return key
	}

	var keyFile = findSigningProperty( "signingKeyFile" )
	if ( keyFile != null ) {
		return new File( keyFile ).text
	}

	return null
}

String findSigningProperty(String propName) {
	if ( System.getProperty( propName ) != null ) {
		logger.lifecycle "Found `{}` as a system property", propName
		return System.getProperty(propName )
	}
	else if ( System.getenv().get( propName ) != null ) {
		logger.lifecycle "Found `{}` as an env-var property", propName
		return System.getenv().get( propName );
	}
	else if ( project.hasProperty( propName ) ) {
		logger.lifecycle "Found `{}` as a project property", propName
		return project.hasProperty( propName )
	}
	else {
		logger.lifecycle "Did not find `{}`", propName
		return null
	}
}


final publishTaskName = "publishPublishedArtifactsPublicationToSonatypeRepository"
final signingTaskName = "signPublishedArtifactsPublication"
final signingTaskPath = project.path + ":" + signingTaskName
final signingExplicitlyRequested = gradle.startParameter.taskNames.contains( signingTaskName )
		|| gradle.startParameter.taskNames.contains( signingTaskPath )

var signingTask = project.tasks.getByName( signingTaskName ) as Sign
var signingExtension = project.getExtensions().getByType(SigningExtension) as SigningExtension

signingTask.doFirst {
	if ( signingKey == null || signingPassword == null ) {
		throw new GradleException(
				"Cannot perform signing without GPG details.  Please set the `signingKey` and `signingKeyFile` properties"
		)
	}
}

if ( signingExplicitlyRequested ) {
	// signing was explicitly requested
	signingExtension.required = true
}
else {
	gradle.taskGraph.whenReady { graph ->
		var publishingTask = project.tasks.getByName( publishTaskName ) as PublishToMavenRepository
		if ( graph.hasTask( signingTask ) ) {
			// signing is scheduled to happen.
			//
			// we know, from above if-check, that it was not explicitly requested -
			// so it is triggered via task dependency. make sure we want it to happen
			if ( graph.hasTask( publishingTask ) ) {
				// we are publishing to Sonatype OSSRH - we need the signing to happen
				signingExtension.required = true
			}
			else {
				// signing was not explicitly requested and we are not publishign to OSSRH
				// so do not sign
				signingTask.enabled = false
			}
		}

	}
}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Release / publishing tasks

task ciBuild {
	dependsOn test, publishToSonatype
}

tasks.release.dependsOn tasks.test, tasks.publishToSonatype
tasks.publishToSonatype.mustRunAfter test


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Ancillary tasks

task showPublications {
	doFirst {
		project.publishing.publications.each { publication ->
			println "Publication (${publication.name}): ${publication.groupId}:${publication.artifactId}:${publication.version}"
			publication.artifacts.each { artifact ->
				println "    > ${artifact}"
			}
		}
	}
}